Codigo: 
    - Borrar comentarios al pedo (X)
    - Hacer nombres de variables mas declarativas (cantArchivos en vez de n en workerCargarMultiplesArchivos) (X)
    - Condicion del while en workerCargarMultiplesArchivos (X)
    - Agregar comentarios sobre decisiones de disenio o cosas no triviales de concurrencia (X)
    - Sin embargo, para máximo paralelo tienen que bloquear antes de computar, así como hicieron 
    en la función máximo. Si no lo hacen, pasa lo mismo que si no lo hicieran en máximo; 
    para hacerlo más eficiente, pueden ir soltando los mutexes a medida que los usan. (X)

Informe: usar texttt{funcion} para destacar codigo (X)
    - Los experimentos están ok, pero faltó profundizar:
        - Tratar de articular mejor el por qué, el cómo, y el para qué de cada experimento. 
        - Falta entendimiento del trade-off de usar muchos threads y una intuición de cuándo convienen estos y 
        hasta qué punto (X, en Conclusiones Finales)
        - cuando no conviene usar concurrencia? dar un ejemplo 
        - Otra parte sobre la que pueden razonar un poco más es sobre la distribución de las palabras usadas y las 
        colisiones 
    - Introduccion: 
        - falto mencionar los experimentos y que evaluan, asi el lector puede tener una idea general del trabajo asi 
        como la importancia del tema (motivacion) (X)
    - Insercion en Lista Enlazada: 
        - Porque se cumpe la propiedad de atomicidad y si esto evita condiciones de carrera (lo mencionan arriba pero 
        no lo explican) (X) 
    - Operaciones del HashMapConcurrente: 
        - ser mas tecnicos, que tamaño tiene el vector? (X)
    - Busqueda del Maximo: 
        - ¿Que problemas puede ocasionar que máximo e incrementar se ejecuten concurrentemente? (X)
        - Como hicieron para proteger estos recursos de condiciones de carrera? Deben bloquear como hicieron en 
        maximo o agregar un timestamp. (X)
    - Cargar Archivo: 
        - En esta parte del codigo usaron un while (index < cantArchivosTotal) que no esta muy bueno Para este tipo de 
        worker es mejor usar cosas que sabes que terminan while (index < cantArchivosTotal) con su solucion si por 
        alguna razon o error, no entra al break, entonces se queda consumiendo memoria (X) 
    - Experimento B: 
        - Conclusion: por que? (X)
    - Experimento D: 
        - Conclusion: hablar de colisiones (X)
    - Conclusiones finales: 
        - falta el tradeoff? siempre me conviene usar mas threads? (X)

Experimento adicional con un libro: 
    - Ideas de experimentos: 
